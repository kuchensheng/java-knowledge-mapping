# 查询性能优化

## 优化数据访问
查询性能低下最基本的原因是访问的数据太多。大部分性能低下的查询都可以通过减少数据访问量的方式进行优化。

+ 是否向数据库请求了不需要的数据。

有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这回给服务器带来额外的负担，并增加网络开销，另外也会消耗应用服务器的CPU和内存资源。比如select * 语法，一般会造成资源的浪费。
+ MySQL是否存在扫描额外的记录。

例如在做关联任务时，要扫描多行才能生成结果集中的异常。扫描的行数对返回的行数的比率通常很小，一般在1:1和10:1之间，不过这个时候也可能非常大。所以有关联任务时，要特别注意。关联任务可拆分，例如：
```sql
mysql> SELECT * FROM tag
    ->	JOIN tag_post ON tag_post.tag_id = tag.tag.id
    ->	JOIN post ON tag_post.post_id = post.id
    ->WHERE tag.tag='mysql'
```
可以拆解为下面的查询语句来代替：
```sql
mysql>SELECT * FROM tag WHERE tag='mysql';
mysql>SELECT * FROM tag_post WHERE tag_id=1234;
mysql>SELECT * FROM post WHERE post.id in (123,456,789,2023); 
```
到底为什么这么做？乍一看，这样做并没有什么好处，原本一条查询，现在却变成了多条查询，返回结果又一模一样。实际上，用分解关联查询有如下优势：
 * 让缓存命中率更高。许多应用程序可以方便地缓存单表查询对应的结果对象。
 * 将查询分解后，执行单个查询可以减少锁竞争
 * 在应用层关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
 * 查询本身效率也可能会有所提升。使用IN()代替关联查询，可以让MySQL按照ID顺序进行查询，这可能比随机的关联查询效率更高。
 * 可以减少冗余记录的查询。

# 分区表
对用户来说，分区表是一个独立的逻辑表，但是底层是由多个物理子表组成。实现分区的代码实际上是对一组底层表的句柄对象的封装。对分区表的请求，都会通过句柄对象转化为对存储引擎的接口调用。所以**分区对于SQL来说是一个完全封装底层实现的黑盒子，对应用是透明的**。每一个分区表都有一个使用#分隔命名的表文件。

MySQL在创建表时使用**PARTITION BY**字句定义每个分区存放的数据。分区的主要目的是将数据按照一个比较粗的粒度分在不同的表中。这样做可以将相关数据存放在一起。MySQL的分区实现比较复杂。分区的特性使CREATE、ALTER等DDL操作更加复杂。

## 分区表的原理
分区表的索引只是在各个底层上各自加上一个完全相同的索引。分区表上的操作按照下面的方式进行：

1. SELECT查询。当查询一个分区表时，分区表先打开并锁住所有的底层表，优化器先判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据。**（有点坑，会锁住所有分区表）**

2. INSERT操作。当写入一条记录时，分区表先打开并锁住所有的底层表，然后确定哪个分区接收这条记录，再将记录写入对应的底层表。

3. DELETE操作。当删除一条记录时，分区表先打开并锁住所有的底层表，然后确定数据对应的分区，最后对相应的底层表进行删除操作。

4. UPDATE操作。当更新一条记录时，分区表先打开并锁住所有的底层表，MySQL先确定需要更新的记录在哪个分区，然后取出所有数据并更新，再判断更新后的数据应该放在哪个分区，最后对底层表进行写入操作，并对原数据所在分区进行删除操作。

**注意：**虽然每个操作都会“先打开并锁住所有的底层表”，但这并不是说分区表在处理过程中是锁住全表的。如果存储引擎能够自己实现行级锁，例如InnoDB，则会在分区层释放对应表锁。这个加锁和释放锁的过程与普通InnoDB上的查询类似。