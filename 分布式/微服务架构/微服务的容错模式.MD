# 微服务的容错模式
## 1.舱壁隔离模式
	主要体现：微服务容器分组：将普通用户和VIP用户的流量分别负载，进行隔离
			 线程池隔离：微服务的不同功能使用线程池，导致流量增加时耗尽线程池中的线程，从而阻塞其他的功能服务
## 2.熔断模式
	避免因为某个服务被压垮时，可以快速失败，导致依赖的服务都被压垮。
## 3.限流模式
	+ 计数器
		通过原子变量计算单位时间内的访问次数，如果超过某个阈值，则拒绝后续的请求。等到下一个单位时间再重新计数
	+ 令牌筒
	+ 信号量
		利用Semaphore来完成信号量设计
## 4.失效转移模式
	通常的失效处理方式有：
	+ 采用快速失败的策略，直接返回适用方错误，让使用方知道发生了问题并自行决定后续处理
	+ 是否有备份服务，如果有备份服务，则切换
	+ 失败的服务可能是某台机器的问题，比如OOM，这种情况下适用failover策略，重试

# 微服务拆分粒度
	按照微服务的初衷，服务要按照业务的功能进行拆分，直到每个服务的功能和职责单一，甚至不可再拆分为止，以至于每个服务能够独立部署，扩容和缩容方便，能够有效地提高利用率。
	提倡对服务的拆分适可而止，原则是拆分到可以让使用方自由地编排底层的子服务来获得相应的组合服务即可，同时要考虑到团队建设及人员数量和分配

# 分布式系统一致性问题

## 一致性问题
	+ 1. 下订单和库存不一致
	+ 2. 同步调用超时
	+ 3. 异步回调超时
	+ 4. 掉单
	+ 5.系统时间不一致
	+ 6.缓存和数据库不一致
	+ 7.本地缓存节点间不一致
	+ 8.缓存数据结构不一致
## 酸碱平衡理论
	+ ACID（酸）
		具有ACID特性的数据库支持强一致性，强一致性代表数据库本身不会出现不一致，每个事务都是原子的，或者成功或者失败，事务间是隔离的，互相完全不受影响，而且最终状态是持久落盘的。一般是通过MVCC来实现
		NoSQL完全不适合交易场景，主要用来做数据分析ETL、报表、数据挖掘、日志处理等非核心交易场景
	+ CAP（帽子理论）
		C：Consistency，一致性。在分布式系统中的所有数据备份，在同一时刻具有同样的值，所有节点在同一时刻读取的数据都是最新的数据副本
		A：Availability，可用性。
		P：Partition tolerance，分区容错
	+ BASE（碱）
		在请求处理过程中，记录其中间状态，根据中间状态来处理未完成的请求或者回退到原始状态
## 分布式一致性协议
	DTS（分布式事务处理模型）中包含了4个角色：
		- 应用程序
		- 事务管理器：全局的管理者
		- 资源管理器
		- 通信资源管理器
	TX协议定义应用程序与事务管理器之间的接口
	XA协议定义事务管理器与资源管理器之间的接口
### 两阶段提交协议
	JEE的XA协议就是根据两阶段提交来保证实物的完成性。
	两阶段提交协议把分布式事务分为两个阶段，一个是准备阶段，一个是提交阶段。准备阶段和提交阶段都是由事务管理器发起。
	流程如下：
	- 准备阶段：事务管理器（协调者）向资源管理器（参与者）发起指令，参与者评估自己的状态，如果参与者评估指令可以完成，则会写redo或者undo日志，然后锁定资源，执行操作，但不提交
	- 提交阶段：如果每个参与者明确返回可以准备成功，也就是预留资源和执行操作成功，则协调者向参与者发起提交指令，参与者提交资源变更的事务，释放锁定资源；如果任何一个参与者明确返回准备失败，也就是预留资源或执行操作失败，则协调者向参与者发起终止指令，参与者取消已经变更的事务，执行undo日志，释放锁定的资源

	致命的问题：
	- 阻塞：被占用的资源长时间阻塞
	- 单点故障：如果协调者宕机，参与者会一直阻塞
	- 脑裂：协调者发起提交指令，有的参与者收到并执行了事务，有的参与者没有接收到指令。多个参与者之间不一致
### 三阶段提交协议
	利用超时机制解决了二阶段提交协议的阻塞问题。流程如下：
	- 询问阶段：协调者询问参与者是否可以完成指令，参与者只需要是或者不是，而不需真正的操作，这个阶段超时会终止
	- 准备阶段：如果在询问阶段所有参与者都返回可以执行操作，则执行二阶段提交流程
### TCC协议
	TCC协议将一个任务拆成Try、Confirm、Cancel三个步骤。本质上还是一个二阶段提交
### 保证最终一致性的模式
	- 查询模式。任何服务操作都需要提供一个查询接口，用来向外部输出操作执行的状态。然后根据不同的状态来做不同的处理操作
	- 补偿模式。