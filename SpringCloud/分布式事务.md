# 微服务的发展
微服务倡导将复杂的单体应用拆分为若干个功能简单的、松耦合的服务，这样可以降低开发难度、增强扩展性、便于敏捷开发。抢单被越来越多的开发者推崇，很过互联网行业巨头、开源社区等都开始了微服务的讨论和实践。当前微服务的开发框架也很多，例如Spring Cloud、Dubbo、thrift和grpc等。
# 微服务落地存在的问题
虽然微服务有诸多好处，但是目前亦存在如下问题：
* 1. 单体应用拆分为分布式系统后，进程间的通信机制和故障处理措施变的更加复杂。
* 2. 系统微服务化后，一个看似简单的功能，内部可能需要调用多个服务并操作多个数据库实现，服务调用的分布式事务问题变的突出。
* 3. 微服务数量众多，其测试、部署、监控都变的更加困难。

随着rpc、devops技术的发展，微服务的第一和第三个问题基本得到解决。

对于第二个问题，现在还没有通用方案很好的解决微服务产生的事务问题。

# SOA分布式事务解决方案
## 基于XA协议的两阶段提交方案
XA规范的基础是两阶段提交协议。第一阶段是表决阶段，所有参与者都将本身事务是否能够成功的信息反馈给协调者；第二阶段是执行阶段，协调者根据所有参与者的反馈，通知所有参与者，步调一致地在所有分支上提交或者回滚事务。

**注意：**两阶段提交方案锁定资源时间长，对性能影响很大，基本不适合解决微服务事务问题。

![XA协议的量阶段提交方案](https://images2018.cnblogs.com/blog/1334519/201803/1334519-20180307150636190-1704712093.png)

## TCC方案
TCC方案在电商、金融领域应用较多，TCC方案其实是两阶段提交的一种改进。其将整个业务逻辑的每个分支显式的分成了try、confirm和cancle三个操作。try部分完成业务的准备工作，confirm部分完成业务的提交，cancle部分完成事务的回滚。

![TCC方案](https://images2018.cnblogs.com/blog/1334519/201803/1334519-20180307150648591-1729601878.png)

事务开始时，业务应用会向事务协调器注册启动事务。之后业务应用会调用所有服务的try接口，完成准备工作。之后事务协调器会根据try接口返回的情况，决定调用confirm还是cancle接口。如果结果调用失败，会进行重试。TCC方案降低锁冲突、提高了吞吐量。

**但是：**

TCC方案对业务侵入性强。每个业务都需要实现try、confirm和cancle操作，改造成本高。

TCC方案实现难度大。需要按照网络状态、系统故障灯不同的失败原因实现不同的回滚策略。TCC方案中很多事物的处理逻辑需要应用自己编码实现，开发量大。

## 基于消息的最终一致性方案
消息一致性方案通过消息中间件保证上、下游应用数据操作的一致性。基本思路是将本地操作和发送消息放在一个事务里，保证本地操作和消息发送要么两者都成功，或者都失败。下游应用向消息系统订阅该消息，收到消息后执行响应的操作。

![基于消息的最终一致性方案](https://images2018.cnblogs.com/blog/1334519/201803/1334519-20180307150703434-1501056265.png)

消息方案从本质上讲是将分布式事务转换为两个本地事务，然后依靠下游业务的重试机制达到最终一致性。基于消息的最终一致性方案对应用侵入性也很高，应用需要进行大量业务改造，成本较高。

## GTS--分布式事务解决方案
### GTS的核心优势
* 性能强。GTS解决了ACID特性与高性能、高可用、低侵入不可兼得的问题。单事务分支的凭据响应时间为2ms，3台服务器组成集群可以支撑30000TPS以上的分布式事务请求。
* 应用侵入性低。GTS对业务低侵入，业务代码最少只需要添加一行注解（@TxcTrasacation)声明事务即可。业务与事务分离，将微服务从事务中解放出来，微服务只关注于业务本身，不再需要考虑反向接口、幂等、回滚策略等复杂问题，极大地降低了开发的难度和工作量。
* 完成的解决方案。GTS支持多种主流的服务框架，包括Dubbo、Spring Cloud和EDAS等。
* 容错能力强。GTS解决了XA事务协调器的单点问题，实现真正的高可用，可以保证各种异常情况下的严格数据一致。

![GTS](https://images2018.cnblogs.com/blog/1334519/201803/1334519-20180307150720354-1188496664.png)

## sagas事务模型
Saga事务模型又叫做长时间运行的事务（Long-running-transaction）。该模型其核心思想就是拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后由 Sagas 工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中实现失败，那么Sagas工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚。

![sagas事务模型](https://images2017.cnblogs.com/blog/250417/201710/250417-20171016220040115-805407978.png)

他们的执行顺序如上图所示，所以当发生失败时，会依次进行取消的补偿操作。




