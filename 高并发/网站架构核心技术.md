# 1 交易系统设计的一些原则
	在系统设计时，应该多考虑**墨菲定律**
		- 任何事都没有表面看起来那么简单
		- 所有的事都会比你预计的时间要长
		- 可能出错的事总会出错
		- 如果你担心某种情况发生，那么它更有可能发生
	在系统划分时，也要思考**康威定律**
		- 系统架构是公司组织架构的反映。、
		- 应该按照业务闭环进行系统拆分/组织架构拆分，实现闭环/高内聚/低耦合，减少沟通成本
		- 如果沟通出现问题，那么就应该考虑进行系统和组织架构的调整
		- 在合适时机进行系统拆分，不要一开始就把系统/服务拆得非常细，虽然闭环，但是每个人维护的系统多，维护成本高
		**应鼓励团队成员积极主动沟通并推动系统演进**。另外也要考虑**二八定律**，在系统设计初期将有限资源用在刀刃上。

## 1.1 高并发原则
### 1.1.1 无状态
			更加容易水平扩展。应用无状态，配置有状态。
### 1.1.2 拆分
			在系统设计初期，是做一个大而全的系统还是按功能模块拆分系统，这个需要根据环境进行权衡。
			拆分维度：
				+ 系统维度：系统按照功能/业务拆分，比如商品系统、购物车、结算、订单系统等。
				+ 功能维度：对一个系统功能再拆分，比如优惠券可以拆分为后台券创建系统、领券系统、用券系统等；
				+ 读写维度：根据读写比例特征来拆分。比如，商品系统，交易的各个系统都会读取数据，读的量大于写，因此可以拆分成商品写服务、商品读服务；读服务可以考虑使用缓存提升性能；写的量大时，需要考虑分库分表；有些聚合读取场景，比如商品的详情页，可以考虑数据异构拆分系统，将分散多出的数据聚合到一处存储，以提升性能和可靠性。
				+ AOP维度：根据访问特征，按照AOP进行拆分，比如商品详情页可以分为CDN、页面渲染系统；CDN就是一个AOP系统
				+ 模块维度：按照基础或者代码维护特征进行拆分，比如基础模块分库分表、数据库连接池等；
### 1.1.3 服务化
			进程内服务→单机远程服务→集群手动注册服务→自动注册和发现服务→服务的分组/隔离/路由→服务治理如限流/黑白名单。
### 1.1.4 消息队列
			消息队列用来解耦一些不需要同步调用的服务或者订阅一些自己关心的变化。
			+ 大流量缓冲。
				电商大促等大流量场景，一般都是通过牺牲强一致性，而保证最终一致性来解决。比如库存扣减，可以在Redis中扣减，然后记录扣减日志，通过Worker同步到DB。在交易订单系统中，首先结算服务调用订单接单服务，将订单存储到订单Redis和订单队列表，订单队列表可以按照需求水平扩展多个表，通过队列缓冲表提升接单能力。然后通过同步Worker同步到订单中心表；假设用户支付了订单，订单状态机会驱动状态变更，此时可能订单队列表的订单还没有同步到订单中心表，状态机要根据实际情况进行重试。如果用户查询某个订单详情，可以直接从订单Redis中查到，如果查询订单列表，可以考虑Redis和列表的合并。
			+ 数据校对
				使用了消息异步机制的场景下，可能存在消息丢失，需要考虑进行数据校对和修正来保证数据的一致性和完整性。可以通过Worker定期去扫描原始表，通过对业务数据进行校对，有问题的可以补偿。
### 1.1.5 数据异构
			+ 数据异构：订单按照订单ID进行分表，会造成用户的订单分散在多个表中，降低了订单表的可读性。可以通过对订单表进行异构，异构一套用户订单表，按照用户ID进行分库分表。
			+ 数据闭环：把使用到的数据进行异构存储，形成数据闭环。把数据从多个数据源拿过来，然后聚合。
### 1.1.6 缓存银弹
			缓存对于读服务来说是抗流量的银弹。
			+ 浏览器端缓存：适用于对实时性不敏感的数据
			+ APP客户端缓存：把一些素材提前下发到客户端进行缓存
			+ CDN缓存：将页面、活动页、图片等推送到距离用户最近的CDN节点上。一般有两种机制：推送机制和拉去机制。
			+ 接入层缓存：如果没有CDN缓存，可以考虑使用Nginx搭建一层接入层，主要实现URL重写、一致性哈希、代理缓存（内存级/SSD级代理缓存）、lock机制，将多个回源合并为一个
			+ 应用层缓存：我们使用Tomcat时，可以使用堆内/堆外缓存。使用redis来使用堆外缓存
			+ 分布式缓存：redis
			+ 并发化

## 1.2 高可用原则
		### 1.2.1 降级
			高可用的一个很重要的设计就是降级开关。
			+ 开关集中化管理：通过推送机制把开环推送到各个应用。
			+ 可降级的多级读服务：比如服务调用降级为只读本地缓存、只读分布式缓存、只读默认降级数据。
			+ 开关前置化：如果是Nginx→Tomcat，可以将开关置于Nginx接入层。
			+ 业务降级：当高并发流量来袭，在电商系统大促设计时保证用户能下单、能支付是核心要求，并保障数据最终一致性即可。这样就把一些同步调用改为异步调用，优先处理高优先级数据或特殊特征的数据，合理分配进入系统的流量，以保证系统可用
### 1.2.2 限流
			防止恶意请求流量、恶意攻击或者防止流量超出系统峰值。
			+ Nginx层使用limit模块来处理
			+ 计数器、信号量、令牌筒来限流
### 1.2.3 切流量
			切流量手段：DNS、HTTPDNS、LVS/HaProxy、Nginx
### 1.2.4 可回滚
			版本化的目的是实现可审计、可回溯，并且可回滚。当程序或数据出错时，如果有版本化机制，那么就可以通过回滚回复到最近一个正确的版本，
## 1.3 业务设计原则 
### 1.3.1 防重设计
			比如，结算页面考虑重复提交，解决方案可以考虑防重key、防重表或者token。将支付的每笔情况记录下来，然后生成key，防重复
### 1.3.2 幂等设计
			查询操作（天然幂等）、删除操作、唯一索引、token机制、悲观锁、乐观锁、分布式锁、状态机。
### 1.3.3 流程可定义
			创建优惠券、领取优惠券和使用优惠券是分离的，在需要时进行关联。
### 1.3.4 状态与状态机
	状态设计应有状态轨迹，方便用户跟踪当前订单的轨迹并记录相关日志，万一出问题，可回溯
### 1.3.5 后台系统操作可反馈

### 1.3.6 后台系统审批华
			对有些重要的后台功能要对操作进行日志记录，从而保证可回溯、可审计
### 1.3.7 文档和注释
	系统一开始就要有文档库（设计架构、设计思想、数据字典/业务流程、现有问题），业务代码和特殊需求都要有注释。
### 1.3.8 备份
			包括代码和人员。

# 2 隔离术
	隔离是指将系统或资源分隔开。系统隔离是为了在系统发生故障时，能限定故障传播范围。资源隔离是通过隔离来减少资源竞争。
	隔离手段有：线程隔离、进程隔离、集群隔离、机房隔离、读写隔离、快慢隔离、动静隔离、爬虫隔离等。
# 3 限流
	在开发高并发系统时，有很多手段保护系统，如缓存、降级和限流等。缓存目的是提升系统访问速度和增大系统处理能力，而降级是当服务出问题或者影响到核心流程的性能，需要暂时屏蔽，待高峰过去或者问题解决后再打开的场景。而有些场景不能用缓存和降级来解决，例如，稀缺资源（秒杀、抢购）、写服务（评论、下单）、频繁的复杂查询（评论的最后几页）等，因此引入限流手段。
	
	限流的目的是通过对并发访问/请求进行限速或者一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率就可以拒绝服务（定向到错误页面或告知资源没有了）、排队或等待（秒杀、平均、下单等场景）、降级（返回兜底数据或默认数据，如商品详情页默认有库存）。

 	一般开发高并发系统常见的限流有：限制总并发数（数据库连接池、线程池）、限制瞬时并发数（Nginx的limit_conn模块）、限制时间窗口内的平均速率（Guava的Ratelimiter、Nginx的limit_req模块），以及限制远程接口调用速率、限制MQ的消费速率等。另外还可以根据网络连接数、网络流量、CPU或内存负载来限流。

	现有缓存银弹，后有限流来应对618、双11高并发流量，在处理高并发问题时，不用担心瞬间流量导致系统挂掉或雪崩，最终做到有损服务而不是不服务。 

## 3.1 限流算法
### 3.1.1 令牌筒算法
	是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。
### 3.1.2 漏桶算法
	漏桶作为计量工具时，可以用于流量整形和流量控制。一个固定容量的桶，按照常亮固定速率流出水滴。
### 3.1.3 其他算法
	计数器限流
## 3.2 应用级限流
### 3.2.1 限流总并发/连接/请求数
	例如使用Tomcat，Connector中有acceptCount、maxConnections、maxThreads来限制
### 3.2.2 限制总资源数
	线程、数据库连接是稀缺资源，连接数必须加以限制，可以使用池化技术来限制总资源数
### 3.2.3 限制某个接口的总并发/请求数
	例如抢购业务，需要限制这个接口的总并发/请求数的总量。可以使用AtomicLong或者Semaphor进行限流
### 3.2.4 限流某个接口的时间窗请求数
	即一个时间窗口内的请求数，例如使用Guava的Cache来存储计数器，过期时间设置为2s。这种方式有点简单粗暴
### 3.2.5 平滑限流某个接口的请求数
	令牌筒或者漏桶算法来实现，Guava框架提供了令牌桶算法实现。Guava RateLimiter提供的令牌桶算法可用于平滑突发限流和平滑预热限流。
## 3.3 分布式限流
分布式限流的关键是将限流服务做成原子化，解决方案可以使用Redis+Lua或者Nginx+Lua（接入层）技术来实现，
### 3.3.1 Redis + Lua
	Redis + Lua实现时间窗内某个接口的请求数限流。目前京东的抢购业务就是使用的这种方式来限流
### 3.3.2 接入层限流
	对于Nginx接入层来说，可以使用Nginx自带的两个模块：连接数限流模块ngx_http_limit_conn_module和漏桶算法实现的请求限流模块ngx_http_limit_req_module，还可以使用OpenResty提供的Lua限流模块lua-resty-limit-traffic来限流
	- limit_conn是对某个key对应的总网络连接数进行限流，例如按照IP/域名来限制IP/域名维度的总连接数
	- limit_req是漏桶算法实现，用于对指定key对应的请求进行限流
	- Nginx也提供了limit_rate模块用来对流量限速，例如limit_rate 50K，表示限制下载速度为50K
 
	
