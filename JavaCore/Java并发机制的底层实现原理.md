Java中所使用的并发机制依赖于JVM的实现和CPU指令
# volatile的应用
volatile保证了共享变量的可见性。也就是说当一个线程修改一个共享变量时，另外一个线程能够读到这个修改的值。如果volatile变量修饰符使用得当，它比synchronized的使用和执行成本更低，因为它不会引起线程上线文的切换和调度。
## volatile的定义与实现原理
CPU的术语定义
| 术语 | 描述 |
|---- | ---- |
|内存屏障(memory barries) | 是一组处理器命令，用于实现对内存操作的顺序限制 |
|缓冲行(cache line) | 缓存中可以分配的最小存储单位。|
|原子操作(atomic operation) | 不可中断的一个或一系列操作|

**volatile如何保证可见性的呢？**
有volatile变量修饰符修饰的共享变量在进行写操作时会有个Lock前缀的指令。这个指令有两个动作：
- 1）将当前处理器缓存行的数据协会系统内存
- 2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效
在多处理器下，为了保证各个处理器的缓存行的缓存是一致就会实现缓存一致性协议。*每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器缓存行设置为无效状态。当处理器对这个数据进行修改的时候，会重新冲系统内存中吧数据读到处理器缓存里*。

## synchronized的实现原理与应用
Java中的每一个对象都可以作为锁。具体表现有以下3种形式：
- 对于普通方法：锁是当前实例对象
- 对于静态方法：锁是当前类的Class对象
- 对于同步方法块：锁是synchronized括号里配置的对象

Synchronized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，使用monitorenter和monitorexit指令实现

Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。

## synchronized锁升级
### 偏向锁
当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后该线程进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要简单测试一下对象头的Mark Word是否存储着当前线程的偏向锁。

偏向锁使用了一种等到竞争退出才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销需要要等待全局安全点。
### 轻量级锁
线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针，如果成功，当前线程获得锁，否则尝试使用自旋来获取锁。
轻量级解锁时，会使用原子的CAS操作将Mark Word替换回到对象头，如果失败，则锁膨胀为重量级锁。
### CAS（原子操作）的实现原理
在处理器中，**使用总线锁保证原子性**，使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号，其他处理器的请求将被阻塞住，name该处理器就可以独占共享内存。**使用缓存锁保证原子性**，总线锁开销大。所以在某些场合和可以使用缓存锁来优化。例如：频繁使用的内存会缓存在处理器的告诉缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不要使用总线锁。

**CAS操作的三大问题**
- ABA问题。ABA问题的解决思路就是使用版本号。在变量前追加版本号，每次变量更新的时候版本号加1.Java中提供了AtomicStampedReferece来解决ABA问题。
- 自旋（循环）时间长开销大。自旋CAS如果长时间不成功，会给CPU带来较大的开销。如果JVM支持处理提供的pause指令，那么效率会有一定的提升。
- 只能保证一个共享变量的操作操作。当对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候可以用锁。
