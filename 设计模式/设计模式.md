# **设计模式**
设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。
# 设计模式的分类
总体来说设计模式分为三大类：
* 创建型模式（Creational Pattern）：对类的实例化过程进行了抽象，能够将软件模式中对象的创建和使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的细节，使整个系统的设计更加符合单一职责原则。

包含的模式共有5个：**工厂方法模式、抽象工厂模式、单例模式、建造者模式和原型模式**
* 结构型模式：**适配器模式、装饰器模式、代理模式、桥接模式、组合模式和享元模式**
* 行为型模式：**策略模式、模版方法模式、观察者模式、迭代模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、仲裁模式、解释器模式**

## 单例模式（Singleton）
全局生成唯一实例

[图解设计模式-单例模式](设计模式/图解设计模式-单例模式.md)
## 工厂模式（Factory）
将实例的生成交给子类

[图解设计模式-工厂模式](设计模式/图解设计模式-工厂模式.md)
## 建造者模式（Builder）
一步一步构建实例

[图解设计模式-建造者模式](设计模式/图解设计模式-建造者模式.md)
## 原型模式（prototype）
通过复制生成实例。
特点：要实现Cloneable接口。区分《[深克隆和浅克隆](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484076&idx=1&sn=0a7aeaeb283c5b2ca77dc4751995288c&chksm=fd9854cdcaefdddb1b6b9c637a14006ac3b54d325dd48ddcfc8a6b4ef74bd6e69a7e5e74eec8#rd)》。
## 适配器模式（Adapter）
使用一个已存在的、但又不符合需求的类，或者要创建一个可重用的类，这是可以考虑使用适配器模式。

适配器分为：类适配器和对象适配器。

类适配器：对象集成的方式，静态的定义

对象适配器：依赖于对象的组合

都是采用对象组合的方式，也就是对象适配器实现

[一起学设计模式](https://segmentfault.com/a/1190000011856448)
## 桥接模式（Bridge）
桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。桥接模式将继承关系转化为关联关系，从而降低类与类之间的耦合，减少了代码编写量。但是由于聚合关系建立在抽象层，所以系统的开发难度比较大

[更多桥接模式的详细内容，请点这里](https://blog.csdn.net/yangzl2008/article/details/7670996)

## 组合模式（Composite）
组合模式能够使容器和内容具有一致性。创造出递归结构的模式就是组合模式。

组合模式又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。

[更多组合模式的内容，请点这里](https://blog.csdn.net/lmb55/article/details/51039781)
## 装饰器模式（Decorator）
动态地给一个对象添加一些额外的职责。当不能采用生成子类的方法进行扩充时，可以采用此模式进行独立的扩展。

[装饰器模式的更多详细信息，请点这里](https://www.cnblogs.com/chenxing818/p/4705919.html)

## 外观模式（Facade）
使用Facade模式可以为互相关联在一起的错综复杂的类整理出高层接口。其中的Facade角色可以让系统对外只有一个简单的接口。这使得子系统更容易被访问或者使用。

![外观模式的详细内容，请点这里](https://images2015.cnblogs.com/blog/1016421/201609/1016421-20160910215031051-160598096.png)

## 享元模式（Flyweight Pattern）
享元模式（Flyweight Pattern），又称轻量级模式（这也是其英文名为FlyWeight的原因），通过共享技术有效地实现了大量细粒度对象的复用。也即**通过尽量共享来避免new出实例**

## 代理模式（Proxy）
**只在必要时，生成实例**。

代理模式使用代理对象完成用户请求，屏蔽用户对真实对象的访问。在软件设计中，使用代理模式的意图也很多，比如因为安全原因需要屏蔽客户端直接访问真实对象，或者在远程调用中需要使用代理类处理远程方法调用的技术细节 (如 RMI)，也可能为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。

[代理模式的详细内容，请点这里](https://www.ibm.com/developerworks/cn/java/j-lo-proxy-pattern/index.html)

## 职责链模式（Chain of Responsibility）
将多个对象组成一条职责链，然后按照它们在职责上的顺序一个一个地找出到底应该谁来负责处理。
## 迭代器模式（Iterator）
一个一个遍历。

**为什么要使用迭代器模式？**

一个重要理由，引入Iterator后可以将遍历与实现分离开。
```
这里的while循环并不依赖于具体对象。
Iterator it = bookshelf.Iterator();
while(it.hasNext()) {
    Book book = (Book)it.next();
    System.out.println(book.getName());
}
```

## 模板方法模式（Template  Method）
**在父类中定义处理流程的框架，在子类中实现具体处理**
## 策略模式（Strategy）
整体地替换算法。策略模式将算法与其他部分分离开，只是定义了与算法相关的接口，然后再程序中以委托的方式来使用算法。
## 访问者模式（Visitor）
访问数据结构并处理数据。数据结构与处理被分离开来。我们编写一个“访问者”的类来访问数据结构中的元素，并把对各元素的处理交给访问者类。这样，当需要增加新的处理时，我们只需要编写新的访问者，然后让数据结构可以接受访问者的访问即可。
## 观察者模式（Observer）
当对象间存在一对多的关系时，则使用观察者模式（Observer）。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

**关键代码**：在抽象类里有一个ArrayList存放观察者们

**优点**：观察者和被观察者是抽象耦合的

**缺点**：如果有循环依赖，可能会导致系统崩溃。观察者没有相应的机制让观察者知道所观察的目标是怎么发生变化的，仅仅是知道观察目标发生了变化

实例代码

```
https://github.com/kuchensheng/designPattern/tree/master/src/com/design/pattern/observer
```

Java自带观察者模式
java类库中的java.util.Observer接口和java.util.Observable类就是一种Observer模式。

java.util.Observer接口中定义了以下方法
```
public void update(Observeable obj,Object arg)
```

## 备忘录模式
存档模式，因为它主要的作用就是保存某个对象内部所需的数据和状态，并且随时可以还原。
[更多备忘录模式，点击这里](http://baijiahao.baidu.com/s?id=1602580371525874178&wfr=spider&for=pc)
## 仲裁者模式
组员想仲裁者报告，仲裁者想组员下达指示
[更多仲裁者模式信息，点击这里](https://www.cnblogs.com/zyrblog/p/9246643.html)
## 解释器模式（Intercepter）
给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
[更多详情点击这里](https://www.cnblogs.com/zhou-yi/p/5462663.html)
## 命令模式（Command）
命令模式（Command Pattern）是一种数据驱动的设计模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。
## 状态模式（State）
在状态模式中，类的行为是基于它的状态改变的。也就是说用类表示状态。

**意图**：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。

**优点**：状态模式是将特定的状态相关的行为放到一个对象中，由于所有与状态相关的代码都存放在某个具体state类中，所以对各个状态的增删改其实就是对子类state的增删改，这样比单类的写法清晰和容易维护多了。

**缺点**：状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 









